# 知光APP用户关系模块技术方案

## 一、概述

本方案旨在为知光APP实现高性能、高一致性、可扩展的用户关系模块，核心功能包括：
- 关注与取关操作
- 关注数与粉丝数统计
- 关注列表与粉丝列表查询
- 用户关系查询（是否互相关注）

方案目标是在高并发场景下保持一致性与高性能读写，采用数据库+Redis+异步消费者的混合架构，并辅以伪从同步与令牌桶限流机制。

---

## 二、系统设计架构

整体架构由以下几部分组成：
- **主存储层（MySQL）**：存储关注关系，following表为主，follower表为伪从。
- **缓存层（Redis）**：负责计数缓存、列表缓存、关系查询缓存及限流令牌桶。
- **异步事件层（Kafka）**：消费关注事件、同步伪从、更新计数与缓存。
- **消费者服务**：计数服务与缓存更新服务分别作为following表的伪从，订阅关注事件。

---

## 三、数据库设计

### 3.1 表结构

#### following表
```sql
CREATE TABLE following (
  id BIGINT PRIMARY KEY,
  from_user_id BIGINT NOT NULL,
  to_user_id BIGINT NOT NULL,
  rel_status TINYINT NOT NULL DEFAULT 1,
  created_at DATETIME(3) NOT NULL,
  updated_at DATETIME(3) NOT NULL,
  UNIQUE KEY uk_from_to (from_user_id, to_user_id),
  KEY idx_from_created (from_user_id, created_at, to_user_id, rel_status),
  KEY idx_to (to_user_id, from_user_id, rel_status)
);
```

#### follower表
```sql
CREATE TABLE follower (
  id BIGINT PRIMARY KEY,
  to_user_id BIGINT NOT NULL,
  from_user_id BIGINT NOT NULL,
  rel_status TINYINT NOT NULL DEFAULT 1,
  created_at DATETIME(3) NOT NULL,
  updated_at DATETIME(3) NOT NULL,
  UNIQUE KEY uk_to_from (to_user_id, from_user_id),
  KEY idx_to_created (to_user_id, created_at, from_user_id, rel_status),
  KEY idx_from (from_user_id, to_user_id, rel_status)
);
```

### 3.2 索引策略
- 使用联合索引 `from_user_id + created_at` 和 `to_user_id + created_at` 以支持分页查询。
- 覆盖索引减少回表，提升查询性能。
- 针对关系判定建立唯一索引避免重复关注。
---

## 四、伪从同步机制

### 4.1 实现方式
- following表作为主表，follower表通过伪从消费其Binlog或消息事件实现同步。
- 同步逻辑：
  - `FollowCreated` → 插入 follower 记录
  - `FollowCanceled` → 更新 rel_status=0 或删除记录
- 幂等保证：以 `(from_user_id,to_user_id)` 作为唯一键去重。

### 4.2 Outbox + 消费者机制（推荐）
- 在following表事务中插入Outbox记录。
- CDC组件（Canal/Debezium）或自研消费者监听Outbox并发送MQ事件。
- follower表、计数服务、缓存服务均从MQ订阅更新。

---

## 五、计数模块设计

### 5.1 数据结构
- 使用Redis **SDS二进制结构**实现紧凑存储。
- Key：`ucnt:{userId}`
- Value：5个Int5字段，分别表示：
  1. 关注数
  2. 粉丝数
  3. 用户作品数
  4. 用户点赞作品数
  5. 用户收藏作品数

### 5.2 同步机制
- 消费 `FollowCreated/FollowCanceled` 事件自动更新计数。
- Redis Lua脚本原子自增/自减。
- 定期对账任务比对数据库计数差异并修正。

---

## 六、缓存设计

### 6.1 列表缓存
- 关注列表：`uf:flws:{userId}` → ZSet(to_user_id, created_at)
- 粉丝列表：`uf:fans:{userId}` → ZSet(from_user_id, created_at)
- 仅缓存最近N条记录（如1000条）。
- 大V用户（粉丝>50W）使用本地Caffeine缓存保存Top 500。

### 6.2 一致性更新
- 消费事件异步更新ZSet缓存：
  - `FollowCreated` → `ZADD`
  - `FollowCanceled` → `ZREM`
- 当缓存不存在时，DB分页查询并回填Redis。

### 6.3 Key TTL
- 列表缓存TTL：1~6小时。
- 计数缓存：永久存储，由事件维护。

---

## 七、限流设计

### 7.1 令牌桶算法
- 每个用户关注操作独立令牌桶：`rl:follow:{userId}`。
- 容量100，填充速率1/s。
- 使用Lua脚本原子取令牌：
  - 当桶为空时拒绝请求，防止短时间恶意关注。
---

## 八、接口设计

| 功能 | 接口 | 方法 | 说明 |
|------|------|------|------|
| 关注 | /relation/follow | POST | 幂等，写following并发事件 |
| 取关 | /relation/unfollow | POST | 更新rel_status=0 |
| 查询关系 | /relation/status | GET | 判断是否互关 |
| 关注列表 | /relation/following | GET | 支持游标分页 |
| 粉丝列表 | /relation/followers | GET | 支持游标分页 |
| 计数查询 | /relation/counter | GET | Redis直读 |

---

## 九、系统一致性与补偿机制

| 模块 | 一致性方式 | 说明 |
|-------|-------------|------|
| following→follower | 异步最终一致 | 通过Outbox+MQ同步 |
| following→计数 | 异步最终一致 | 事件驱动更新Redis |
| following→缓存 | 异步更新 | 通过MQ推送ZSet操作 |
| Redis计数→DB | 离线校对 | 每日对账修复 |

---

## 十、异常与恢复机制

- **事件幂等**：事件ID+用户ID作为幂等键。
- **延迟容忍**：客户端显示乐观更新，后端异步补偿。
- **Redis容灾**：AOF everysec，多副本部署；每日计数快照备份。
- **冷备回放**：MQ消息保留14天，可重放恢复。

---